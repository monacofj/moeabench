<!--
SPDX-FileCopyrightText: 2026 Monaco F. J. <monaco@usp.br>
SPDX-FileCopyrightText: 2026 Silva F. F. <fernandoferreira.silva42@usp.br>

SPDX-License-Identifier: GPL-3.0-or-later
-->

# Registro de Discussão: Restauração da Persistência (Save/Load)

Esta seção documenta a análise técnica e o planejamento para a restauração das funcionalidades de salvamento e carregamento do MoeaBench após a refatoração da arquitetura.

## Planejamento de Implementação

Para restaurar a funcionalidade de `save` e `load`, o sistema deve evoluir de uma simples exportação de dados brutos para um mecanismo de persistência de trajetórias completo. O design proposto foca na integridade do estado do experimento e na utilidade dos dados para ferramentas externas.

### O Modelo de Persistência Proposto

O objetivo central é que o comando `save` gere um pacote comprimido (ZIP) contendo três pilares de informação:

1.  **MoeaBench.joblib**: O núcleo da persistência. Utilizaremos a biblioteca `joblib` para serializar o objeto `experiment` em sua totalidade. Isso preserva todas as instâncias de `Run`, o histórico geracional completo, as sementes aleatórias e os hiperparâmetros. Ao carregar este arquivo, o usuário retorna exatamente ao ponto em que parou, com todas as ferramentas de análise estatística e visualização prontas para uso.
2.  **Resultados em CSV**: Para garantir a interoperabilidade com ecossistemas externos (como R, MATLAB ou Excel), o pacote incluirá um `result.csv` contendo o `superfront` (a frente não-dominada consolidada de todas as execuções) e um `pof.csv` com a frente analítica teórica, permitindo análise rápida sem necessidade do ambiente Python.
3.  **Metadados de Referência (problem.txt)**: Um arquivo de texto legível por humanos descrevendo as configurações fundamentais do experimento: o problema resolvido, o algoritmo utilizado, tamanho da população, número de gerações e o total de execuções realizadas.

### Implementação Técnica

A implementação envolverá a limpeza de referências obsoletas ao antigo sistema de CACHE e a correção das dependências de módulos inexistentes (`core.file`). Os métodos `save` e `load` na classe `experiment` serão simplificados para atuar como interfaces para estas rotinas de exportação e importação, garantindo um código limpo e de fácil manutenção.

---

## Evolução: Modos Seletivos de Persistência

A inclusão de granularidade no salvamento através de um argumento opcional de modo (ex: `mode='all'`, `'config'`, `'data'`) foi identificada como uma melhoria significativa para a flexibilidade do framework.

### Modos de Operação no `save()`

*   **`mode='config'`**: Foca na reprodutibilidade científica. Salva apenas o "esqueleto" do experimento — hiperparâmetros do algoritmo e definição do problema — sem os dados pesados das trajetórias. Isso permite compartilhar a configuração exata de um estudo em um arquivo extremamente leve.
*   **`mode='data'`**: Persiste apenas as trajetórias e resultados. É ideal para quando a configuração já é conhecida ou está fixa no script, e o interesse reside apenas em salvar o resultado de horas de computação intensiva.
*   **`mode='all'`**: O padrão do sistema, garantindo a persistência total do estado.

### Comportamento do `load()`

O método `load()` deve atuar de forma simétrica e inteligente. Ao carregar um arquivo, ele deve detectar automaticamente o que está disponível. Se for solicitado um carregamento de configuração (`mode='config'`) em um arquivo que contém resultados, o sistema deve reconstruir o experimento, mas inicializar os dados (como a lista de `runs`) como vazios, permitindo uma nova execução baseada no setup original.

---

## Cenários de Uso para Salvamento de Dados Apenas

A opção de salvar exclusivamente os dados (`mode='data'`) atende a requisitos específicos de pós-processamento e eficiência operacional:

1.  **Exportação e Pós-processamento Externo**: Quando a fase de otimização termina, o interesse do pesquisador muitas vezes se desloca para a geração de gráficos para publicações ou tabelas em outras plataformas. Nestes casos, a infraestrutura do algoritmo e do problema tornam-se redundantes, e apenas os pontos da frente de Pareto são necessários.
2.  **Eficiência de Armazenamento em Larga Escala**: Em problemas que utilizam modelos pesados (como redes neurais ou substitutos de alto custo), salvar o objeto completo repetidamente pode consumir gigabytes de disco desnecessariamente. Se a configuração de 100 experimentos é idêntica, salvar apenas os dados produzidos economiza recursos críticos.
3.  **Privacidade e Anonimização**: Permite compartilhar os sucessos (os dados obtidos) em repositórios de dados abertos sem necessariamente expor a lógica proprietária do algoritmo ou detalhes confidenciais do código do problema.
4.  **Pontos de Verificação (Checkpoints)**: Serve como mecanismo de segurança durante execuções longas, permitindo salvamentos frequentes dos dados acumulados sem o overhead de serializar o objeto mestre continuamente.

---

## Validação e Demonstração (Exemplo 09)

Para consolidar a implementação, criamos o **Exemplo 09** (disponível como script Python e Notebook Jupyter), que atua como o manual vivo desta funcionalidade. Ele demonstra o ciclo completo de:
1. Execução de um experimento multi-run.
2. Salvamento parcial e total usando os novos modos.
3. Restauração seletiva de dados em objetos pré-configurados.

Este exemplo serve como prova de conceito da estabilidade da serialização, especialmente na remoção automática de atributos não-pickláveis (como o `toolbox` do DEAP) via o novo método `__getstate__` da classe base.
