<!--
SPDX-FileCopyrightText: 2025 Monaco F. J. <monaco@usp.br>
SPDX-FileCopyrightText: 2025 Silva F. F. <fernandoferreira.silva42@usp.br>

SPDX-License-Identifier: GPL-3.0-or-later
-->

# Estratificação Conjunta ou Análise de Tier

Essa é uma ideia excelente e toca exatamente no ponto onde a estatística de MOEAs se torna uma "análise forense" da busca. O que implementamos até agora em `mb.stats.strata` é o que chamamos de **Estratificação Interna** (o algoritmo contra ele mesmo, para medir pressão de seleção e profundidade da busca). O que estamos descrevendo agora é a **Estratificação Conjunta** ou **Análise de Tier**.

### O Plano de Voo: "Competitive Stratification"

A lógica segue a narrativa da **Tier**: colocamos os dois "experimentos" em um único espaço de objetivos e vemos quem sobrevive na linha de frente.

1.  **Fusão e Rotulagem**: Pegamos as frentes de pareto finais de todas as execuções do Algoritmo A e do Algoritmo B. Rotulamos cada solução com sua origem ('A' ou 'B') para não perdermos a rastreabilidade.
2.  **NDS Global**: Executamos o *Non-Dominated Sorting* (vectorized, claro) sobre a união dessas frentes. Isso criará um novo conjunto de ranks (Rank 1, Rank 2, ...) que agora representam a qualidade *relativa* entre os dois algoritmos.
3.  **Contabilização de Resultados**: Para cada rank global, contamos quantas soluções vieram de A e quantas vieram de B.

### Como avaliaríamos o resultado?

Aqui entra a parte rica da métrica. Sugerimos não apenas um vetor de contagem, mas três indicadores principais:

*   **Dominance Ratio no Rank 1**: Este é o "ouro". Se o Rank 1 Global (a verdadeira fronteira de pareto da união) for composto por 90% de soluções do Algoritmo A, temos um vencedor absoluto em termos de qualidade extrema.
*   **A "Profundidade de Soterramento" (Displacement Depth)**: Se as soluções do Algoritmo B só começarem a aparecer no Rank 3 ou 4 da Tier, dizemos que o Algoritmo A "enterrou" o B. Isso mostra que mesmo as melhores soluções de B são dominadas por camadas intermediárias de A.
*   **Vetor de Proporção (Tier Profile)**: Um vetor onde cada posição $k$ contém a razão $\frac{A_k}{A_k + B_k}$. Se for próximo de 1, A domina o rank; se for 0.5, há equilíbrio; se for próximo de 0, B domina.

### Visualização: Strataplot vs Rankplot

Vemos duas formas de contar essa história visualmente:

1.  **Tier Strataplot (Stacked Bars)**: Usaríamos o `strataplot`, mas em vez de barras simples, seriam **barras empilhadas**. No eixo X temos os Ranks Globais (1, 2, 3...) e a altura da barra mostra o total de soluções. A cor da pilha (ex: Azul para A, Laranja para B) mostra quem "manda" naquele rank. Se a primeira barra for toda azul e a laranja só aparecer na quinta barra, o diagnóstico visual de dominância total é imediato.
2.  **Relative Rankfplot**: Poderíamos adaptar o `rankplot` (o "floating plot") para mostrar a "Qualidade Relativa". No eixo vertical (densidade), veríamos onde a massa de soluções de cada algoritmo se concentra em relação aos ranks da tier.

### Diferença para o `attainment_diff`

O `attainment_diff` que fizemos é baseado em **Volume/Espaço**. Ele diz: "O Algoritmo A cobre uma área maior".
A **Competitive Stratification** é baseada em **Frequência/Solução**. Ela diz: "O Algoritmo A produz mais soluções de elite que o B".

Às vezes um algoritmo cobre mais área (HV maior), mas o outro produz soluções muito mais "afiadas" em uma região específica. A estratificação conjunta revela esse "bullying" estatístico de forma muito mais didática.

Nomenclatura sugerida: `mb.stats.tier(exp1, exp2)`. Um nome que honra o estilo de narrativa que estamos construindo. Sugere um "confronto direto".
