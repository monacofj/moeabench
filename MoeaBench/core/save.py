# SPDX-FileCopyrightText: 2025 Monaco F. J. <monaco@usp.br>
# SPDX-FileCopyrightText: 2025 Silva F. F. <fernandoferreira.silva42@usp.br>
#
# SPDX-License-Identifier: GPL-3.0-or-later

from joblib import dump
import numpy as np
import zipfile
from io import BytesIO, StringIO
import pathlib
import json
import datetime
import hashlib
import sys
import os
from .. import system

class save:   
    @staticmethod
    def _prepare_path(folder: str) -> pathlib.Path:
        path = pathlib.Path(folder)
        if path.suffix != '.zip':
            path = path.with_suffix('.zip')
        return path

    @staticmethod
    def IPL_save(obj, folder, mode='all'):
        """
        Saves the experiment to a ZIP archive with enhanced scientific metadata (v2).
        """
        path_z = save._prepare_path(folder)
        
        # Determine what to save based on mode
        save_config = mode in ['all', 'config']
        save_data = mode in ['all', 'data']
        
        # Prepare content for ZIP
        dt_moeabench = []
        dt_moeabench.append(f"MoeaBench Experiment: {obj.name}\n")
        dt_moeabench.append("=" * 40 + "\n")
        
        if obj.mop:
            dt_moeabench.append(f"Problem: {obj.mop.__class__.__name__}")
            dt_moeabench.append(f"  Objectives (M): {obj.mop.M}")
            dt_moeabench.append(f"  Variables (N): {obj.mop.N}\n")
            
        if obj.moea:
            dt_moeabench.append(f"Algorithm: {obj.moea.__class__.__name__}")
            if hasattr(obj.moea, 'population'):
                dt_moeabench.append(f"  Population: {obj.moea.population}")
            if hasattr(obj.moea, 'generations'):
                dt_moeabench.append(f"  Generations: {obj.moea.generations}\n")

        dt_moeabench.append(f"Total Runs: {len(obj.runs)}")
        dt_moeabench.append(f"Persistence Mode: {mode}\n")
        
        # 0. Generate metadata.json (Scientific Reproducibility)
        m_provenance = {
            "moeabench": system.version(),
            "python": sys.version.split()[0],
            "platform": sys.platform,
            "timestamp_utc": datetime.datetime.utcnow().isoformat() + "Z"
        }
        
        # Try to capture key dependency versions
        for dep in ["numpy", "scipy", "pymoo", "pandas"]:
            try:
                mod = __import__(dep)
                m_provenance[f"{dep}_version"] = mod.__version__
            except (ImportError, AttributeError):
                pass

        # Baseline Hash for auditability
        from ..diagnostics import baselines
        try:
            b_path = baselines.BASELINE_JSON_PATH
            if os.path.exists(b_path):
                with open(b_path, "rb") as f:
                    b_hash = hashlib.sha256(f.read()).hexdigest()
                m_provenance["baseline_hash"] = b_hash
        except Exception:
            m_provenance["baseline_hash"] = "unknown"

        m_context = {
            "name": obj.name,
            "authors": obj.authors,
            "license": obj.license,
            "year": obj.year,
            "mode": mode
        }
        
        # 0.1 Create README.md with SPDX headers
        readme_lines = []
        # REUSE-IgnoreStart
        if obj.authors:
            readme_lines.append(f"SPDX-FileCopyrightText: {obj.year} {obj.authors}")
        if obj.license:
            readme_lines.append(f"SPDX-License-Identifier: {obj.license}")
        # REUSE-IgnoreEnd
        
        readme_lines.extend([
            "",
            f"# MoeaBench Experiment: {obj.name}",
            "",
            "## Scientific Metadata",
            f"- **Authors**: {obj.authors if obj.authors else 'Anonymous'}",
            f"- **License**: {obj.license} (c) {obj.year}",
            f"- **MoeaBench Version**: {m_provenance['moeabench']}",
            f"- **Execution Date**: {m_provenance['timestamp_utc']}",
            "",
            "## Configuration",
            f"- **Problem (MOP)**: {obj.mop.__class__.__name__ if obj.mop else 'None'}",
            f"- **Algorithm (MOEA)**: {obj.moea.__class__.__name__ if obj.moea else 'None'}",
            f"- **Total Runs**: {len(obj.runs)}",
            "",
            "---",
            "*This archive was generated by MoeaBench Persistence Layer v2.*"
        ])

        with zipfile.ZipFile(path_z, 'w') as zf:
            # metadata.json
            metadata = {"provenance": m_provenance, "context": m_context}
            zf.writestr('metadata.json', json.dumps(metadata, indent=2))
            
            # README.md
            zf.writestr('README.md', "\n".join(readme_lines))
            
            # 1. Problem description (Legacy compatibility)
            zf.writestr('problem.txt', "\n".join(dt_moeabench))
            
            # 2. Export CSVs (only if we have runs and mode allows data)
            if save_data and len(obj.runs) > 0:
                # Save the Global Non-Dominated Front (Superfront)
                try:
                    sf = obj.front()
                    header = ",".join([f'objective_{i+1}' for i in range(sf.shape[1])])
                    mem_csv = StringIO()
                    np.savetxt(mem_csv, sf, delimiter=",", fmt="%.16f", header=header, comments='')
                    zf.writestr('result.csv', mem_csv.getvalue())
                except Exception:
                    pass

                # Optimal Front (if available)
                try:
                    if hasattr(obj.mop, 'pf'):
                        pof = obj.mop.pf(500)
                        header = ",".join([f'objective_{i+1}' for i in range(pof.shape[1])])
                        mem_csv_pof = StringIO()
                        np.savetxt(mem_csv_pof, pof, delimiter=",", fmt="%.16f", header=header, comments='')
                        zf.writestr('pof.csv', mem_csv_pof.getvalue())
                except Exception:
                    pass

            # 3. Serialization of the object
            # If mode is 'config', we clone and clear runs
            # If mode is 'data', we basically save everything (filtering on load is easier) 
            # but per user request we can filter here.
            
            target_obj = obj
            if mode == 'config':
                import copy
                target_obj = copy.copy(obj)
                target_obj._runs = []
            
            mem_obj = BytesIO()
            dump(target_obj, mem_obj)
            mem_obj.seek(0)
            zf.writestr('Moeabench.joblib', mem_obj.read())

        return str(path_z)

        



   

        
 
